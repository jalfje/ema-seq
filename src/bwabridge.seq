from fixes import *
## bwabridge.seq
# Extends seq's default bwa connection with ema-specific data and functions.
# This is *extremely closely copied* from ema's bwabridge.h, just converted to seq syntax.

import math
import util
import bio.bwa as seq_bwa

MEM_MAPQ_COEF: float = 30.0

class EasyAlignment:
    offset: int
    aln_end: int
    contig: str
    score: int
    read_start: int
    read_end: int
    chained_hit: seq_bwa.mem_alnreg_t
    rev: bool
    sec: bool

    def __init__(self: EasyAlignment):
        pass

    # equivalent to bwabridge::interpret_chain
    def __init__(self: EasyAlignment, ref: seq_bwa.bwaidx_t, aln: seq_bwa.mem_alnreg_t):
        contigs: seq_bwa.bntseq_t = ref._bns[0]
        contig: seq_bwa.bntann1_t = contigs._anns[aln.rid]

        if aln.rb < contigs._l_pac:
            self.offset = aln.rb - int(contig._offset)
            self.rev = False
        else:
            self.offset = int(contigs._l_pac) * 2 - 1 - aln.rb - int(contig._offset)
            self.rev = True

        if aln.re < contigs._l_pac:
            self.aln_end = aln.re - int(contig._offset)
        else:
            self.aln_end = int(contigs._l_pac) * 2 - 1 - aln.re - int(contig._offset)

        self.contig = util.c_str_to_str(contig._name)
        self.sec = aln.secondary >= 0 or aln.secondary_all > 0
        self.score = aln.score
        self.read_start = aln.qb
        self.read_end = aln.qe
        self.chained_hit = aln

class SingleReadAlignment:
    pos: int
    chrom: str
    alt: bool
    mapq: int
    edit_dist: int
    cigar: CIGAR
    alt_mappings: str
    score: int
    sub: int
    alt_score: int
    rev: bool

    def __init__(self: SingleReadAlignment):
        self.cigar = list[int]()

    # equivalent to bwabridge::interpret_single_read_alignment
    def __init__(self: SingleReadAlignment, ref: seq_bwa.bwaidx_t, aln: seq_bwa.mem_aln_t):
        contigs: seq_bwa.bntseq_t = ref._bns[0]
        contig: seq_bwa.bntann1_t = contigs._anns[aln.rid]

        self.pos = aln.pos
        self.chrom = util.c_str_to_str(contig._name)
        self.cigar = aln.cigar
        self.alt = aln.alt
        self.mapq = aln.mapq
        self.rev = aln.rev
        self.score = aln.score
        self.sub = aln.sub
        self.edit_dist = aln.NM
        self.alt_score = aln.alt_score

class EasyAlignmentPairs:
    a1: list[EasyAlignment]
    a2: list[EasyAlignment]

    def __init__(self: EasyAlignmentPairs):
        a1 = list[EasyAlignment]()
        a2 = list[EasyAlignment]()

# Copied from align::mem_approx_mapq_se_insist, which was copied (with one change)
# from bwamem::mem_approx_mapq_se
def mem_approx_mapq_se_insist(bwa: seq_bwa.BWA, a: seq_bwa.mem_alnreg_t):
    opts = ptr[byte](bwa.opt)
    # opts is a pointer to a mem_opt_t object
        # - mapQ_coef_len # ptr[u32](ptr[byte](opts) + 28 * 4)[0]
        # - mapQ_coef_fac # int(ptr[i32](ptr[byte](opts) + 29 * 4)[0])
        # - min_seed_len  # int(ptr[i32](ptr[byte](opts) + 15 * 4)[0])
    opt_a = int(ptr[i32](opts + 0 * 4)[0])
    opt_b = int(ptr[i32](opts + 1 * 4)[0])
    opt_min_seed_len = int(ptr[i32](opts + 15 * 4)[0])
    opt_mapQ_coef_len = util.u32_to_float(ptr[u32](opts + 28 * 4)[0])
    opt_mapQ_coef_fac = int(ptr[i32](opts + 29 * 4)[0])

    sub = a.sub if a.sub != 0 else opt_min_seed_len * opt_a
    sub = max(a.csub, sub)
    if sub >= a.score:
        return 0

    l = int(max(a.qe - a.qb, a.re - a.rb))
    identity = 1.0 - float(l * opt_a - a.score) / float(opt_a + opt_b) / float(l)

    mapq: int = 0
    if a.score == 0:
        mapq = 0
    elif opt_mapQ_coef_len > 0:
        tmp = 1.0 if float(l) < opt_mapQ_coef_len else opt_mapQ_coef_fac / math.log(float(l))
        tmp *= identity * identity
        mapq = int(6.02 * (a.score - sub) / opt_a * tmp * tmp + 0.499)
    else:
        mapq = int(MEM_MAPQ_COEF * (1.0 - float(sub) / float(a.score)) * math.log(float(a.seedcov)) + 0.499)
        if identity < 0.95:
            mapq = int(mapq * identity * identity + 0.499)

    if a.sub_n > 0:
        mapq -= int(4.343 * math.log(float(a.sub_n + 1)) + 0.499)
    if mapq > 254:
        mapq = 254
    if mapq < 0:
        mapq = 0

    a_frac_rep = util.u32_to_float(a._frac_rep) # convert u32 to float
    mapq = int(float(mapq) * (1.0 - a_frac_rep) + 0.499)
    return mapq


def bwa_mem_mate_sw(bwa: seq_bwa.BWA, read1: seq, len1: int, read2: seq, len2: int, score_delta: int)-> EasyAlignmentPairs:
    raise NotImplementedError() # TODO: implement

def bwa_smith_waterman(bwa: seq_bwa.BWA, read: seq, len: int, aln: seq_bwa.mem_alnreg_t)-> SingleReadAlignment:
    raise NotImplementedError() # TODO: implement
