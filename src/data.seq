## data.seq
# Various data class and type definitions

type bc_t = int
type chrom_t = int

# FastQRecord: Contains data for a single barcoded FASTQ record
class FastQRecord(object):
    barcode: bc_t
    ident: str
    read: str
    qual: str

    def __init__(self: FastQRecord, barcode: bc_t, ident: str, read: str, qual: str):
        self.barcode = barcode
        self.ident = ident
        self.read = read
        self.qual = qual

# Barcodes are 16-element sequences (ACGT/acgt). This converts them to a 32-bit integer,
# with higher bits based on later elements.
encode_barcode_dict = {'a': bc_t(0), 'c': bc_t(1), 'g': bc_t(2), 't': bc_t(3),
                       'A': bc_t(0), 'C': bc_t(1), 'G': bc_t(2), 'T': bc_t(3)}
def encode_barcode(bc: str)-> bc_t:
    encoded = bc_t(0)
    for c in reversed(bc):
        encoded <<= 2
        encoded += encode_barcode_dict[c]
    return encoded



### Clouds


_cloud_id = 0
class Cloud:
    exp_cov: float
    weight: float

    hi: int
    lo: int

    parent: Cloud
    child: Cloud

    ident: int
    bad: bool

    def __init__(self: Cloud):
        self.exp_cov = 0.0
        self.weight = 0.0
        self.hi = 0
        self.lo = 0
        self.parent = None
        self.child = None
        self.ident = _cloud_id
        _cloud_id += 1
        self.bad = False

def normalize_cloud_probabilities(clouds: list[Cloud]):
    # Find parent clouds, and normalize all child clouds based on that
    for cloud in clouds:
        if cloud.parent != None:
            continue

        total = 0.0
        c = cloud
        while c != None:
            total += c.weight
            c = c.child

        c = cloud
        while c != None:
            c.weight /= total
            c = c.child



### SamRecord


# Needed to implement this myself because Seq's native implementation is sorely lacking
class SamRecord:
    barcode: bc_t
    chrom: chrom_t
    pos: int

    ident: str
    score: float
    mapq: int # BWA MEM's mapq
    score_mapq: int # Our computed mapq
    clip: int
    clip_edit_dist: int # Edit distance including clipping

    self_hash: int
    mate_hash: int

    mate: bool
    rev: bool
    self_hashed: bool
    mate_hashed: bool
    duplicate: bool
    unique: bool
    active: bool
    visited: bool

    gamme: float
    cloud: Cloud # pointer to cloud containing this record

    fq: FastQRecord # Pointer to read that this was from
    fq_mate: FastQRecord # Pointer to read that the mate was from

    selected_mate: SamRecord
    alignment: SingleReadAlignment

    def __init__(self: SamRecord):
        pass # TODO: implement? or default-initialize everything? (do things even get default-initialized? I know bools do)

def sam_record_cmp_key(record: SamRecord):
    return (record.barcode, record.chrom, record.pos, record.ident)

def sam_name_cmp_key(record: SamRecord):
    return (record.ident, record.mate)

def sam_duplicate_cmp_key(record: SamRecord):
    return (record.barcode,
            record.mate,
            record.rev,
            record.chrom,
            record.pos,
            record.selected_mate.chrom if record.selected_mate is not None else 0xFFFFFFFF,
            record.selected_mate.pos if record.selected_mate is not None else 0xFFFFFFFF)
