from fixes import *
## data.seq
# Various data class and type definitions

from bwabridge import SingleReadAlignment

type bc_t = int

# Global variable for simplicity; consistent with C version. Not ideal coding practices here.
_chroms = list[str]()
def chrom_index(chrom: str)-> int:
    return _chroms.index(chrom)
def chrom_lookup(index: int)-> str:
    return _chroms[index]

# FastQRecord: Contains data for a single barcoded FASTQ record
class FastQRecord:
    barcode: bc_t
    ident: str
    read: str
    qual: str

    def __init__(self: FastQRecord, barcode: bc_t, ident: str, read: str, qual: str):
        self.barcode = barcode
        self.ident = ident
        self.read = read
        self.qual = qual


### Clouds


_cloud_id = id_generator()
class Cloud:
    exp_cov: float
    weight: float

    hi: int
    lo: int

    parent: Cloud
    child: Cloud

    ident: int
    bad: bool

    def __init__(self: Cloud):
        self.exp_cov = 0.0
        self.weight = 0.0
        self.hi = 0
        self.lo = 0
        self.parent = None
        self.child = None
        self.ident = next(_cloud_id)
        self.bad = False

def normalize_cloud_probabilities(clouds: list[Cloud]):
    # Find parent clouds, and normalize all child clouds based on that
    for cloud in clouds:
        if cloud.parent is not None:
            continue

        total = 0.0
        c = cloud
        while c is not None:
            total += c.weight
            c = c.child

        c = cloud
        while c is not None:
            c.weight /= total
            c = c.child


### SamRecord

class Alt:
    chrom: str
    pos: int
    edit_dist: int
    cigar: str
    rev: bool

    def __init__(self: Alt):
        pass

# Needed to implement this myself because Seq's native implementation is sorely lacking
class SamRecord:
    barcode: bc_t
    chrom: int
    pos: int

    ident: str
    score: float
    mapq: int # BWA MEM's mapq
    score_mapq: int # Our computed mapq
    clip: int
    clip_edit_dist: int # Edit distance including clipping

    mate: bool
    rev: bool
    duplicate: bool
    unique: bool
    active: bool
    visited: bool

    gamma: float
    cloud: Cloud # pointer to cloud containing this record

    fq: FastQRecord # Pointer to read that this was from
    fq_mate: FastQRecord # Pointer to read that the mate was from

    selected_mate: SamRecord
    alignment: SingleReadAlignment
    alts: list[Alt]

    def __init__(self: SamRecord):
        self.alts = list[Alt]()

    # For bwa bridge. Equivalent to align::alignment_to_sam_rec
    def __init__(self: SamRecord, fq: FastQRecord, fq_mate: FastQRecord, aln: SingleReadAlignment,
                 mate: bool, clip: int, clip_edit_dist: int):
        self.barcode = fq.barcode
        self.chrom = chrom_index(aln.chrom)
        self.pos = aln.pos + 1

        self.ident = fq.ident[1:] # skip leading @

        score_alignment(r, s) # TODO: score_alignment

        self.fq = fq
        self.fq_mate = fq_mate
        self.alignment = aln
        self.mate = mate
        self.clip = clip
        self.clip_edit_dist = clip_edit_dist

        self.rev = aln.rev
        self.unique = False
        self.duplicate = False
        self.active = True
        self.visited = False

        self.gamma = 0
        self.cloud = None
        self.selected_mate = None
        self.alts = list[Alt]()



    ## These have to be here due to github.com/seq-lang/seq/issues/168
    def __eq__(self: SamRecord, other: SamRecord)-> bool:
        raise NotImplementedError()
    def __lt__(self: SamRecord, other: SamRecord)-> bool:
        raise NotImplementedError()
    def __gt__(self: SamRecord, other: SamRecord)-> bool:
        raise NotImplementedError()
    def __le__(self: SamRecord, other: SamRecord)-> bool:
        raise NotImplementedError()
    def __ge__(self: SamRecord, other: SamRecord)-> bool:
        raise NotImplementedError()


def sam_record_cmp_key(record: SamRecord):
    return (record.barcode, record.chrom, record.pos, record.ident)

def sam_name_cmp_key(record: SamRecord):
    return (record.ident, record.mate)

def sam_duplicate_cmp_key(record: SamRecord):
    return (record.barcode,
            record.mate,
            record.rev,
            record.chrom,
            record.pos,
            record.selected_mate.chrom if record.selected_mate is not None else 0xFFFFFFFF,
            record.selected_mate.pos if record.selected_mate is not None else 0xFFFFFFFF)
