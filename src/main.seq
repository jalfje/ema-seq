from fixes import *
## main.seq
## seq script which runs EMA alignment pipeline.

import sys
import getopt
import time

from bio.bwa import *
from bio.fai import *
from bio.fastq import FASTQ

from techs import PlatformProfile, platform_profiles
from align import *
from input_reader import InputReader
import util

KB = 1024
MB = KB * 1024
GB = MB * 1024
VERSION: str = "0.0.2"
program_arguments: list[str] = list[str]()

# Exit the program with success value
def exit_success():
    sys.exit(0)

# Exit the program with failure value
def exit_failure():
    sys.exit(1)

# Print the help message
def print_help():
    #print f"usage: {program_arguments[0]} <count|preproc|align|help|version> [options]"
    print f"usage: {program_arguments[0]} <align|help|version> [options]"
    print ""
    #print "count: perform preliminary barcode count (takes interleaved FASTQ via stdin)"
    #print "  -w <whitelist path>: specify barcode whitelist [required]"
    #print "  -o <output prefix>: specify output prefix [required]"
    #print ""
    #print "preproc: preprocess barcoded FASTQ files (takes interleaved FASTQ via stdin)"
    # print "  -w <whitelist path>: specify whitelist [required]"
    # print "  -n <num buckets>: number of barcode buckets to make [500]"
    # print "  -h: apply Hamming-2 correction [off]"
    # print "  -o: <output directory> specify output directory [required]"
    # print "  -b: output BX:Z-formatted FASTQs [off]"
    # print "  -t <threads>: set number of threads [1]"
    # print "  all other arguments: list of all output prefixes generated by count stage"
    # print ""
    print "align: choose best alignments based on barcodes"
    print "  -1 <FASTQ1 path>: first (preprocessed and sorted) FASTQ file [none]"
    print "  -2 <FASTQ2 path>: second (preprocessed and sorted) FASTQ file [none]"
    print "  -s <EMA-FASTQ path>: specify special FASTQ path [none]"
    print "  -x: multi-input mode; takes input files after flags and spawns a thread for each [off]"
    print "  -r <FASTA path>: indexed reference [required]"
    print "  -o <SAM file>: output SAM file [stdout]"
    print "  -R <RG string>: full read group string ['@RG\\tID:rg1\\tSM:sample1']"
    #print "  -d: apply fragment read density optimization [off]"
    print "  -p <platform>: sequencing platform (one of '10x', 'tru', 'cpt') [10x]"
    print "  -i <index>: index to follow 'BX' tag in SAM output ['1']"
    #print "  -t <threads>: set number of threads [1]"
    print "  all other arguments (only for -x): list of all preprocessed inputs"
    print ""
    print "version: print the installed version number"
    print ""
    print "help: print this help message"

# Parse options & run preprocessing mode
# PREPROCCESSING MODE NOT IMPLEMENTED
def run_preproc(options: list[str]):
    opts, unused_opts = getopt.getopt(options, "w:n:hbo:t:")

    wl = str() # Barcode whitelist
    nbuckets = 500 # Number of barcode buckets
    do_h2 = False # Do 2-distance hamming distance correction?
    out = str() # Output filename
    t = 1 # Number of threads
    do_bx_format = False # Not quite sure yet

    for hyphenated_opt, value in opts:
        opt = hyphenated_opt[1]
        match opt:
            case 'w':
                wl = value
            case 'n':
                nbuckets = int(value)
            case 'h':
                do_h2 = True
            case 'o':
                out = value
            case 't':
                t = int(value)
            case 'b':
                do_bx_format = True
            case _:
                print f"Unknown preproc option {hyphenated_opt}"
                print_help()
                exit_failure()

    if len(wl) == 0:
        print "Error: Specify barcode whitelist with -w"
        exit_failure()

    if len(out) == 0:
        print "Error: Specify output directory with -o"
        exit_failure()

    if len(unused_opts) == 0:
        print "Warning: No input files specified; nothing to do"
        exit_success()

    raise NotImplementedError()
    #Preproc.preproc(wl, unused_opts, len(unused_opts), out, do_h2, 10*MB, do_bx_format, t, nbuckets)
    exit_success()

# Parse options & run count mode
# COUNT MODE NOT IMPLEMENTED
def run_count(options: list[str]):
    opts, unused_opts = getopt.getopt(options, "w:o:")

    wl = str() # Barcode whitelist
    out = str() # Output prefix

    for hyphenated_opt, value in opts:
        opt = hyphenated_opt[1]
        match opt:
            case 'w':
                wl = value
            case 'o':
                out = value
            case _:
                print f"Unknown count option {hyphenated_opt}"
                print_help()
                exit_failure()

    if len(wl) == 0:
        print "Error: Specify barcode whitelist with -w"
        exit_failure()

    if len(out) == 0:
        print "Error: Specify output prefix with -o"
        exit_failure()

    raise NotImplementedError()
    #Count.count(wl, out, 1*GB)
    exit_success()

# Parse options & run align mode
def run_align(options: list[str]):
    opts, unused_opts = getopt.getopt(options, "r:1:2:s:xo:R:dp:i:t:")

    # Declare parameters
    rg = "@RG\tID:rg1\tSM:sample1" # read group (with set default)
    ref = str() # reference genome file
    fq1 = str() # first fastq file
    fq2 = str() # (optional) second fastq file
    fqx = str() # special fastq file
    out = str() # output file
    apply_opt = False # -d optimization
    multi_input = False # multiple input flag
    platform = "10x" # technology
    bx_index = "1"
    t = 1 # number of threads

    # Parse options
    for hyphenated_opt, value in opts:
        opt = hyphenated_opt[1]
        match opt:
            case 'r':
                ref = value
            case '1':
                fq1 = value
            case '2':
                fq2 = value
            case 's':
                fqx = value
            case 'x':
                multi_input = True
            case 'o':
                out = value
            case 'R':
                rg = util.escape(value)
            #case 'd':
            #    apply_opt = True # TODO: implement
            case 'p':
                platform = value
            case 'i':
                bx_index = value
            #case 't':
            #    t = int(value) # TODO: implement
            case _:
                print f"Unknown align option {hyphenated_opt}"
                print_help()
                exit_failure()

    # Validate options
    if not (multi_input ^ (len(fqx) != 0) ^ (len(fq1) != 0 or len(fq2) != 0)):
        print "Error: Must specify *exactly one* of -1/-2, -s, or -x"
        exit_failure()

    if len(fq1) == 0 and len(fq2) != 0:
        print "Error: Cannot specify -2 without -1"
        exit_failure()

    if len(ref) == 0:
        print "Error: Specify reference FASTA with -r"
        exit_failure()

    if len(rg) != 0 and not util.validate_read_group(rg):
        print f"Error: Malformed read group: {rg}"
        exit_failure()

    tech: PlatformProfile = PlatformProfile()
    try:
        tech = platform_profiles[platform]
    except KeyError:
        print f"Error: Invalid platform name: {platform}"
        exit_failure()

    # Get chromosome names from reference index file
    fai_filename = ref + ".fai"
    global _chroms
    _chroms = [entry.name for entry in FAI(fai_filename)]

    bwa = BWA(ref)
    # Based on config in ema::align::bwa_init and memory mapping in bwa::bwamem.h::mem_opt_t
    p = ptr[i32](ptr[byte](bwa.opt) + 21 * 4); p[0] = i32(3000) # opt->max_occ = 3000

    # Open SAM file or direct to stdout
    out_file = sys.stdout if len(out) == 0 else open(out, "w")

    util.write_sam_header(out_file, bwa.p[0], rg, program_arguments, VERSION)

    if multi_input:
        if len(unused_opts) == 0:
            print "Warning: No input files specified; nothing to do"
            exit_success()

        # TODO: parallelize across t threads
        for filename in unused_opts:
            with open(filename, "r") as input_file:
                reader = InputReader("special", tech, input_file, None)
                find_clouds_and_align(bwa, reader, out_file, apply_opt, tech, 1, rg, bx_index)
    elif len(fqx) != 0: # special
        # TODO: Test
        # TODO: Figure out if this works with stdin, and if not, how to make it work
        with open(fqx, "r") as input_file:
            reader = InputReader("special", tech, input_file, None)
            find_clouds_and_align(bwa, reader, out_file, apply_opt, tech, t, rg, bx_index)
    elif len(fq2) == 0: # interleaved single-file standard fastq
        # TODO: Test
        # TODO: Figure out if this works with stdin, and if not, how to make it work
        with open(fq1, "r") as input_file:
            reader = InputReader("interleaved", tech, input_file, None)
            find_clouds_and_align(bwa, reader, out_file, apply_opt, tech, t, rg, bx_index)
    else: # standard fastq; one file for reads and one file for read mates
        # TODO: Test
        with open(fq1, "r") as read_file:
            with open(fq2, "r") as mate_file:
                reader = InputReader("normal", tech, read_file, mate_file)
                find_clouds_and_align(bwa, reader, out_file, apply_opt, tech, t, rg, bx_index)

    out_file.close()
    exit_success()


# Run the main program
def main(argv: list[str]):
    global program_arguments
    program_arguments = argv

    if len(argv) < 2:
        print f"EMA-seq version {VERSION}"
        print f"No arguments supplied"
        print f"Use '{program_arguments[0]} help' for usage information"
        exit_failure()

    mode = argv[1]

    match mode:
        case "preproc":
            print "Error: preprocessing mode not implemented. Use the original EMA implementation for that."
            exit_failure()
            run_preproc(argv[2:])
        case "count":
            print "Error: count mode not implemented. Use the original EMA implementation for that."
            exit_failure()
            run_count(argv[2:])
        case "align":
            run_align(argv[2:])
        case "help":
            print_help()
            exit_success()
        case "version":
            print f"EMA-seq version {VERSION}"
            exit_success()
        case _:
            print "Error: Unrecognized mode"
            print_help()
            exit_failure()

# Run main program
main(sys.argv)
