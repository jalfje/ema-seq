from fixes import *
## main.seq
## seq script which runs EMA alignment pipeline.

import sys
import getopt

from bio.bwa import *
from bio.fai import *
from bio.fastq import FASTQ

from techs import PlatformProfile, platform_profiles
from align import *
import util

KB = 1024
MB = KB * 1024
GB = MB * 1024
VERSION: str = "0.0.1"
argv0: str = ""

# Exit the program with success value
def exit_success():
    sys.exit(0)

# Exit the program with failure value
def exit_failure():
    sys.exit(1)

# Print the help message
def print_help():
	print f"usage: {argv0} <count|preproc|align|help> [options]"
	print ""
	print "count: perform preliminary barcode count (takes interleaved FASTQ via stdin)"
	print "  -w <whitelist path>: specify barcode whitelist [required]"
	print "  -o <output prefix>: specify output prefix [required]"
	print ""
	print "preproc: preprocess barcoded FASTQ files (takes interleaved FASTQ via stdin)"
	print "  -w <whitelist path>: specify whitelist [required]"
	print "  -n <num buckets>: number of barcode buckets to make [500]"
	print "  -h: apply Hamming-2 correction [off]"
	print "  -o: <output directory> specify output directory [required]"
	print "  -b: output BX:Z-formatted FASTQs [off]"
	print "  -t <threads>: set number of threads [1]"
	print "  all other arguments: list of all output prefixes generated by count stage"
	print ""
	print "align: choose best alignments based on barcodes"
	print "  -1 <FASTQ1 path>: first (preprocessed and sorted) FASTQ file [none]"
	print "  -2 <FASTQ2 path>: second (preprocessed and sorted) FASTQ file [none]"
	print "  -s <EMA-FASTQ path>: specify special FASTQ path [none]"
	print "  -x: multi-input mode; takes input files after flags and spawns a thread for each [off]"
	print "  -r <FASTA path>: indexed reference [required]"
	print "  -o <SAM file>: output SAM file [stdout]"
	print "  -R <RG string>: full read group string (e.g. '@RG\\tID:foo\\tSM:bar') [none]"
	print "  -d: apply fragment read density optimization [off]"
	print "  -p <platform>: sequencing platform (one of '10x', 'tru', 'cpt') [10x]"
	print "  -i <index>: index to follow 'BX' tag in SAM output ["
	print "  -t <threads>: set number of threads [1]"
	print "  all other arguments (only for -x): list of all preprocessed inputs"
	print "help: print this help message"

# Parse options & run preprocessing mode
# PREPROCCESSING MODE NOT IMPLEMENTED
def run_preproc(options: list[str]):
    opts, unused_opts = getopt.getopt(options, "w:n:hbo:t:")

    wl = str()
    nbuckets = 500
    do_h2 = False
    out = str()
    t = 1
    do_bx_format = False

    for hyphenated_opt, value in opts:
        opt = hyphenated_opt[1]
        if opt == 'w':
            wl = value
        elif opt == 'n':
            nbuckets = int(value)
        elif opt == 'h':
            do_h2 = True
        elif opt == 'o':
            out = value
        elif opt == 't':
            t = int(value)
        elif opt == 'b':
            do_bx_format = True
        else:
            print_help()
            exit_failure()

    if len(wl) == 0:
        print "Error: Specify barcode whitelist with -w"
        exit_failure()

    if len(out) == 0:
        print "Error: Specify output directory with -o"
        exit_failure()

    if len(unused_opts) == 0:
        print "Warning: No input files specified; nothing to do"
        exit_success()

    raise NotImplementedError()
    #Preproc.preproc(wl, unused_opts, len(unused_opts), out, do_h2, 10*MB, do_bx_format, t, nbuckets)
    exit_success()

# Parse options & run count mode
# COUNT MODE NOT IMPLEMENTED
def run_count(options: list[str]):
    opts, unused_opts = getopt.getopt(options, "w:o:")

    wl = str()
    out = str()

    for hyphenated_opt, value in opts:
        opt = hyphenated_opt[1]
        if opt == 'w':
            wl = value
        elif opt == 'o':
            out = value
        else:
            print_help()
            exit_failure()

    if len(wl) == 0:
        print "Error: Specify barcode whitelist with -w"
        exit_failure()

    if len(out) == 0:
        print "Error: Specify output prefix with -o"
        exit_failure()

    raise NotImplementedError()
    #Count.count(wl, out, 1*GB)
    exit_success()

# Parse options & run align mode
def run_align(options: list[str], program_argv: list[str]):
    opts, unused_opts = getopt.getopt(options, "r:1:2:s:xo:R:dp:i:t:")

    # Declare parameters
    rg = str() # read group
    ref = str() # reference genome file
    fq1 = str() # first fastq file
    fq2 = str() # (optional) second fastq file
    fqx = str() # special fastq file
    out = str() # output file
    apply_opt = False # -d optimization
    multi_input = False # multiple input flag
    platform = "10x" # technology
    bx_index = "1"
    t = 1

    # Parse options
    for hyphenated_opt, value in opts:
        opt = hyphenated_opt[1]
        if opt == 'r':
            ref = value
        elif opt == '1':
            fq1 = value
        elif opt == '2':
            fq2 = value
        elif opt == 's':
            fqx = value
        elif opt == 'x':
            multi_input = True
        elif opt == 'o':
            out = value
        elif opt == 'R':
            rg = util.escape(value)
        elif opt == 'd':
            apply_opt = True
        elif opt == 'p':
            platform = value
        elif opt == 'i':
            bx_index = value
        elif opt == 't':
            t = int(value)
        else:
            print_help()
            exit_failure()

    # Validate options
    if multi_input ^ (len(fqx) != 0) ^ (len(fq1) != 0 or len(fq2) != 0):
        print "Error: Must specify *exactly one* of -1/-2, -s, or -x"
        exit_failure()

    if len(fq1) == 0 and len(fq2) != 0:
        print "Error: Cannot specify -2 without -1"
        exit_failure()

    if len(ref) == 0:
        print "Error: Specify reference FASTA with -r"
        exit_failure()

    if len(rg) != 0 and not util.validate_read_group(rg):
        print f"Error: Malformed read group: {rg}"
        exit_failure()

    tech: PlatformProfile = PlatformProfile()
    try:
        tech = platform_profiles[platform]
    except KeyError:
        print f"Error: Invalid platform name: {platform}"
        exit_failure()

    # Parse remaining parameters
    out_file = sys.stdout if len(out) == 0 else open(out, "w")

    # Get chromosome names from reference index file
    fai_filename = ref + ".fai"
    global _chroms
    _chroms = [entry.name for entry in FAI(fai_filename)]

    bwa = BWA(ref)
    # Based on config in align.c::bwa_init
    p = ptr[i32](ptr[byte](bwa.opt) + 20 * 4); p[0] = i32(3000) # opt->max_occ = 3000

    util.write_sam_header(out_file, bwa.p[0], rg, program_argv, VERSION)

    if multi_input:
        if len(unused_opts) == 0:
            print "Warning: No input files specified; nothing to do"
            exit_success()

        open_input_files = [open(f, "r") for f in unused_opts]

        # TODO Future work: parallelize across t threads
        for input_file in open_input_files:
            find_clouds_and_align_special_fastq(bwa, input_file, out_file, apply_opt, tech, 1, rg, bx_index)
            input_file.close()

    elif len(fqx) != 0:
        fqx_file = open(fqx, "r")

        find_clouds_and_align_special_fastq(bwa, fqx_file, out_file, apply_opt, tech, t, rg, bx_index)

        fqx_file.close()

    else: # standard fastq
        fq1_file = FASTQ(fq1)
        fq2_file = FASTQ(fq2) if len(fq2) != 0 else fq1_file

        find_clouds_and_align_standard_fastq(bwa, fq1_file, fq2_file, out_file, apply_opt, tech, t, rg, bx_index)

    out_file.close()
    exit_success()


# Run the main program
def main(argc: int, argv: list[str]):
    argv0 = argv[0]

    if argc < 2:
        # Why on earth does seq not use python3-style print() as a function??
        print f"EMA-seq version {VERSION}"
        print f"Note: Use '{argv0} help' for usage information"
        exit_success()

    mode = argv[1]

    if mode == "preproc":
        print "Error: preprocessing mode not implemented. Use the original EMA implementation for that."
        #run_preproc(argv[2:])
    elif mode == "count":
        print "Error: count mode not implemented. Use the original EMA implementation for that."
        #run_count(argv[2:])
    elif mode == "align":
        run_align(argv[2:], program_argv=argv)
    elif mode == "help":
        print_help()
        exit_success()
    else:
        print "Error: Unrecognized mode"
        print_help()
        exit_failure()

# Run main program
main(len(sys.argv), sys.argv)
